/**
* Copyright 2017 ZuInnoTe (JÃ¶rn Franke) <zuinnote@gmail.com>
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/

package org.zuinnote.hadoop.ethereum.format.common;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.List;

import org.junit.Test;
import org.zuinnote.hadoop.ethereum.format.exception.EthereumBlockReadException;

/**
 * @author jornfranke
 *
 */
public class EthereumFormatReaderTest {
	static final int DEFAULT_BUFFERSIZE=64*1024;
	static final int DEFAULT_MAXSIZE_ETHEREUMBLOCK=1 * 1024 * 1024;
	
	 @Test
	  public void checkTestDataGenesisBlockAvailable() {
		ClassLoader classLoader = getClass().getClassLoader();
		String fileName="ethgenesis.bin";
		String fileNameGenesis=classLoader.getResource("testdata/"+fileName).getFile();	
		assertNotNull("Test Data File \""+fileName+"\" is not null in resource path",fileNameGenesis);
		File file = new File(fileNameGenesis);
		assertTrue("Test Data File \""+fileName+"\" exists", file.exists());
		assertFalse("Test Data File \""+fileName+"\" is not a directory", file.isDirectory());
	  }
	 
	 @Test
	  public void parseGenesisBlockAsEthereumRawBlockHeap() throws IOException, EthereumBlockReadException {
		ClassLoader classLoader = getClass().getClassLoader();
		String fileName="ethgenesis.bin";
		String fileNameBlock=classLoader.getResource("testdata/"+fileName).getFile();	
		File file = new File(fileNameBlock);
		boolean direct=false;
		FileInputStream fin = new FileInputStream(file);
		EthereumBlockReader ebr = null;
		try {
			ebr = new EthereumBlockReader(fin,this.DEFAULT_MAXSIZE_ETHEREUMBLOCK, this.DEFAULT_BUFFERSIZE,direct);
			ByteBuffer blockByteBuffer = ebr.readRawBlock();
			assertFalse("Raw Genesis Block is HeapByteBuffer", blockByteBuffer.isDirect());
			assertEquals("Raw Genesis block has a size of 540 bytes", 540, blockByteBuffer.limit());
		} finally {
			if (ebr!=null) {
				ebr.close();
			}
		}
	  }
	 
	 @Test
	  public void parseGenesisBlockAsEthereumRawBlockDirect() throws IOException, EthereumBlockReadException {
		ClassLoader classLoader = getClass().getClassLoader();
		String fileName="ethgenesis.bin";
		String fileNameBlock=classLoader.getResource("testdata/"+fileName).getFile();	
		File file = new File(fileNameBlock);
		boolean direct=true;
		FileInputStream fin = new FileInputStream(file);
		EthereumBlockReader ebr = null;
		try {
			ebr = new EthereumBlockReader(fin,this.DEFAULT_MAXSIZE_ETHEREUMBLOCK, this.DEFAULT_BUFFERSIZE,direct);
			ByteBuffer blockByteBuffer = ebr.readRawBlock();
			assertTrue("Raw Genesis Block is DirectByteBuffer", blockByteBuffer.isDirect());
			assertEquals("Raw Genesis block has a size of 540 bytes", 540, blockByteBuffer.limit());
		} finally {
			if (ebr!=null) {
				ebr.close();
			}
		}
	  }
	 
	 @Test
	  public void parseGenesisBlockAsEthereumBlockHeap() throws IOException, EthereumBlockReadException, ParseException {
		ClassLoader classLoader = getClass().getClassLoader();
		String fileName="ethgenesis.bin";
		String fileNameBlock=classLoader.getResource("testdata/"+fileName).getFile();	
		File file = new File(fileNameBlock);
		boolean direct=false;
		FileInputStream fin = new FileInputStream(file);
		EthereumBlockReader ebr = null;
		try {
			ebr = new EthereumBlockReader(fin,this.DEFAULT_MAXSIZE_ETHEREUMBLOCK, this.DEFAULT_BUFFERSIZE,direct);
			EthereumBlock eblock = ebr.readBlock();
			EthereumBlockHeader eblockHeader = eblock.getEthereumBlockHeader();
			List<EthereumTransaction> eTransactions = eblock.getEthereumTransactions();
			List<EthereumBlockHeader> eUncles = eblock.getUncleHeaders();
			assertEquals("Genesis block contains 0 transactions", 0, eTransactions.size());
			assertEquals("Genesis block contains 0 uncleHeaders",0, eUncles.size());
			byte[] expectedParentHash = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a 32 byte hash consisting only of 0x00", expectedParentHash, eblockHeader.getParentHash());
			byte[] expectedUncleHash = new byte[] {(byte) 0x1D,(byte) 0xCC,0x4D,(byte) 0xE8,(byte) 0xDE, (byte) 0xC7,(byte) 0x5D,
					(byte) 0x7A,(byte) 0xAB,(byte) 0x85,(byte) 0xB5,(byte) 0x67,(byte) 0xB6,(byte) 0xCC,(byte) 0xD4,
					0x1A,(byte) 0xD3,(byte)0x12, 0x45,0x1B,(byte) 0x94,(byte) 0x8A,0x74,0x13,(byte) 0xF0,
					(byte) 0xA1,0x42,(byte) 0xFD,0x40,(byte) 0xD4,(byte) 0x93,0x47};
			assertArrayEquals("Genesis block contains a correct 32 byte uncle hash", expectedUncleHash, eblockHeader.getUncleHash());
			byte[] expectedCoinbase = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a 20 byte coinbase consisting only of 0x00",expectedCoinbase,eblockHeader.getCoinBase());
			byte[] expectedStateRoot= new byte[] {(byte) 0xD7,(byte) 0xF8,(byte) 0x97,0x4F,(byte) 0xB5,(byte) 0xAC,0x78,(byte) 0xD9,(byte) 0xAC,0x09,(byte) 0x9B,(byte) 0x9A,(byte) 0xD5,0x01,(byte) 0x8B,(byte) 0xED,(byte) 0xC2,(byte) 0xCE,0x0A,0x72,(byte) 0xDA,(byte) 0xD1,(byte) 0x82,0x7A,0x17,0x09,(byte) 0xDA,0x30,0x58,0x0F,0x05,0x44};
			assertArrayEquals("Genesis block contains a correct 32 byte stateroot",expectedStateRoot,eblockHeader.getStateRoot());
			byte[] expectedTxTrieRoot= new byte[] {0x56,(byte) 0xE8,0x1F,0x17,0x1B,(byte) 0xCC,0x55,(byte) 0xA6,(byte) 0xFF,(byte) 0x83,0x45,(byte) 0xE6,(byte) 0x92,(byte) 0xC0,(byte) 0xF8,0x6E,0x5B,0x48,(byte) 0xE0,0x1B,(byte) 0x99,0x6C,(byte) 0xAD,(byte) 0xC0,0x01,0x62,0x2F,(byte) 0xB5,(byte) 0xE3,0x63,(byte) 0xB4,0x21};
			assertArrayEquals("Genesis block contains a correct 32 byte txTrieRoot",expectedTxTrieRoot,eblockHeader.getTxTrieRoot());	
			byte[] expectedReceiptTrieRoot=new byte[] {0x56,(byte) 0xE8,0x1F,0x17,0x1B,(byte) 0xCC,0x55,(byte) 0xA6,(byte) 0xFF,(byte) 0x83,0x45,(byte) 0xE6,(byte) 0x92,(byte) 0xC0,(byte) 0xF8,0x6E,0x5B,0x48,(byte) 0xE0,0x1B,(byte) 0x99,0x6C,(byte) 0xAD,(byte) 0xC0,0x01,0x62,0x2F,(byte) 0xB5,(byte) 0xE3,0x63,(byte) 0xB4,0x21};
			assertArrayEquals("Genesis block contains a correct 32 byte ReceiptTrieRoot",expectedReceiptTrieRoot,eblockHeader.getReceiptTrieRoot());
			byte[] expectedLogsBloom = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a 256 byte log bloom consisting only of 0x00", expectedLogsBloom, eblockHeader.getLogsBloom());
			byte[] expectedDifficulty = new byte[] {0x04,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a correct 5 byte difficulty", expectedDifficulty, eblockHeader.getDifficulty());
			assertEquals("Genesis block contains a timestamp of 0",0L, eblockHeader.getTimestamp());
			long expectedNumber = 0L;
			assertEquals("Genesis block contains a number 0", expectedNumber, eblockHeader.getNumber());
			byte[] expectedGasLimit = new byte[] {0x13,(byte) 0x88};
			assertArrayEquals("Genesis block contains a correct 2 byte gas limit", expectedGasLimit, eblockHeader.getGasLimit());
			long expectedGasUsed = 0L;
			assertEquals("Genesis block contains a gas used of  0", expectedGasUsed, eblockHeader.getGasUsed());
			byte[] expectedMixHash= new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a correct 32 byte mix hash consisting only of 0x00", expectedMixHash, eblockHeader.getMixHash());
			byte[] expectedExtraData= new byte[] {0x11,(byte) 0xBB,(byte) 0xE8,(byte) 0xDB,0x4E,0x34,0x7B,0x4E,(byte) 0x8C,(byte) 0x93,0x7C,0x1C,(byte) 0x83,0x70,(byte) 0xE4,(byte) 0xB5,(byte) 0xED,0x33,(byte) 0xAD,(byte) 0xB3,(byte) 0xDB,0x69,(byte) 0xCB,(byte) 0xDB,0x7A,0x38,(byte) 0xE1,(byte) 0xE5,0x0B,0x1B,(byte) 0x82,(byte) 0xFA};
			assertArrayEquals("Genesis block contains correct 32 byte extra data", expectedExtraData, eblockHeader.getExtraData());
			byte[] expectedNonce = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42};
			assertArrayEquals("Genesis block contains a correct 8 byte nonce", expectedNonce, eblockHeader.getNonce());
		} finally {
			if (ebr!=null) {
				ebr.close();
			}
		}
	  }
	 

	 
	 @Test
	  public void parseGenesisBlockAsEthereumBlockDirect() throws IOException, EthereumBlockReadException, ParseException {
		ClassLoader classLoader = getClass().getClassLoader();
		String fileName="ethgenesis.bin";
		String fileNameBlock=classLoader.getResource("testdata/"+fileName).getFile();	
		File file = new File(fileNameBlock);
		boolean direct=true;
		FileInputStream fin = new FileInputStream(file);
		EthereumBlockReader ebr = null;
		try {
			ebr = new EthereumBlockReader(fin,this.DEFAULT_MAXSIZE_ETHEREUMBLOCK, this.DEFAULT_BUFFERSIZE,direct);
			EthereumBlock eblock = ebr.readBlock();
			EthereumBlockHeader eblockHeader = eblock.getEthereumBlockHeader();
			List<EthereumTransaction> eTransactions = eblock.getEthereumTransactions();
			List<EthereumBlockHeader> eUncles = eblock.getUncleHeaders();
			assertEquals("Genesis block contains 0 transactions", 0, eTransactions.size());
			assertEquals("Genesis block contains 0 uncleHeaders",0, eUncles.size());
			byte[] expectedParentHash = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a 32 byte hash consisting only of 0x00", expectedParentHash, eblockHeader.getParentHash());
			byte[] expectedUncleHash = new byte[] {(byte) 0x1D,(byte) 0xCC,0x4D,(byte) 0xE8,(byte) 0xDE, (byte) 0xC7,(byte) 0x5D,
					(byte) 0x7A,(byte) 0xAB,(byte) 0x85,(byte) 0xB5,(byte) 0x67,(byte) 0xB6,(byte) 0xCC,(byte) 0xD4,
					0x1A,(byte) 0xD3,(byte)0x12, 0x45,0x1B,(byte) 0x94,(byte) 0x8A,0x74,0x13,(byte) 0xF0,
					(byte) 0xA1,0x42,(byte) 0xFD,0x40,(byte) 0xD4,(byte) 0x93,0x47};
			assertArrayEquals("Genesis block contains a correct 32 byte uncle hash", expectedUncleHash, eblockHeader.getUncleHash());
			byte[] expectedCoinbase = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a 20 byte coinbase consisting only of 0x00",expectedCoinbase,eblockHeader.getCoinBase());
			byte[] expectedStateRoot= new byte[] {(byte) 0xD7,(byte) 0xF8,(byte) 0x97,0x4F,(byte) 0xB5,(byte) 0xAC,0x78,(byte) 0xD9,(byte) 0xAC,0x09,(byte) 0x9B,(byte) 0x9A,(byte) 0xD5,0x01,(byte) 0x8B,(byte) 0xED,(byte) 0xC2,(byte) 0xCE,0x0A,0x72,(byte) 0xDA,(byte) 0xD1,(byte) 0x82,0x7A,0x17,0x09,(byte) 0xDA,0x30,0x58,0x0F,0x05,0x44};
			assertArrayEquals("Genesis block contains a correct 32 byte stateroot",expectedStateRoot,eblockHeader.getStateRoot());
			byte[] expectedTxTrieRoot= new byte[] {0x56,(byte) 0xE8,0x1F,0x17,0x1B,(byte) 0xCC,0x55,(byte) 0xA6,(byte) 0xFF,(byte) 0x83,0x45,(byte) 0xE6,(byte) 0x92,(byte) 0xC0,(byte) 0xF8,0x6E,0x5B,0x48,(byte) 0xE0,0x1B,(byte) 0x99,0x6C,(byte) 0xAD,(byte) 0xC0,0x01,0x62,0x2F,(byte) 0xB5,(byte) 0xE3,0x63,(byte) 0xB4,0x21};
			assertArrayEquals("Genesis block contains a correct 32 byte txTrieRoot",expectedTxTrieRoot,eblockHeader.getTxTrieRoot());	
			byte[] expectedReceiptTrieRoot=new byte[] {0x56,(byte) 0xE8,0x1F,0x17,0x1B,(byte) 0xCC,0x55,(byte) 0xA6,(byte) 0xFF,(byte) 0x83,0x45,(byte) 0xE6,(byte) 0x92,(byte) 0xC0,(byte) 0xF8,0x6E,0x5B,0x48,(byte) 0xE0,0x1B,(byte) 0x99,0x6C,(byte) 0xAD,(byte) 0xC0,0x01,0x62,0x2F,(byte) 0xB5,(byte) 0xE3,0x63,(byte) 0xB4,0x21};
			assertArrayEquals("Genesis block contains a correct 32 byte ReceiptTrieRoot",expectedReceiptTrieRoot,eblockHeader.getReceiptTrieRoot());
			byte[] expectedLogsBloom = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a 256 byte logs bloom consisting only of 0x00", expectedLogsBloom, eblockHeader.getLogsBloom());
			byte[] expectedDifficulty = new byte[] {0x04,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a correct 5 byte difficulty", expectedDifficulty, eblockHeader.getDifficulty());
			assertEquals("Genesis block contains a timestamp of 0",0L, eblockHeader.getTimestamp());
			long expectedNumber = 0L;
			assertEquals("Genesis block contains a number 0", expectedNumber, eblockHeader.getNumber());
			byte[] expectedGasLimit = new byte[] {0x13,(byte) 0x88};
			assertArrayEquals("Genesis block contains a correct 2 byte gas limit", expectedGasLimit, eblockHeader.getGasLimit());
			long expectedGasUsed = 0L;
			assertEquals("Genesis block contains a gas used of  0", expectedGasUsed, eblockHeader.getGasUsed());
			byte[] expectedMixHash= new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Genesis block contains a correct 32 byte mix hash consisting only of 0x00", expectedMixHash, eblockHeader.getMixHash());
			byte[] expectedExtraData= new byte[] {0x11,(byte) 0xBB,(byte) 0xE8,(byte) 0xDB,0x4E,0x34,0x7B,0x4E,(byte) 0x8C,(byte) 0x93,0x7C,0x1C,(byte) 0x83,0x70,(byte) 0xE4,(byte) 0xB5,(byte) 0xED,0x33,(byte) 0xAD,(byte) 0xB3,(byte) 0xDB,0x69,(byte) 0xCB,(byte) 0xDB,0x7A,0x38,(byte) 0xE1,(byte) 0xE5,0x0B,0x1B,(byte) 0x82,(byte) 0xFA};
			assertArrayEquals("Genesis block contains correct 32 byte extra data", expectedExtraData, eblockHeader.getExtraData());
			byte[] expectedNonce = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42};
			assertArrayEquals("Genesis block contains a correct 8 byte nonce", expectedNonce, eblockHeader.getNonce());
		} finally {
			if (ebr!=null) {
				ebr.close();
			}
		}
	  }
	 
	 @Test
	  public void parseBlockOneAsEthereumBlockHeap() throws IOException, EthereumBlockReadException, ParseException {
		ClassLoader classLoader = getClass().getClassLoader();
		String fileName="eth1.bin";
		String fileNameBlock=classLoader.getResource("testdata/"+fileName).getFile();	
		File file = new File(fileNameBlock);
		boolean direct=false;
		FileInputStream fin = new FileInputStream(file);
		EthereumBlockReader ebr = null;
		try {
			ebr = new EthereumBlockReader(fin,this.DEFAULT_MAXSIZE_ETHEREUMBLOCK, this.DEFAULT_BUFFERSIZE,direct);
			EthereumBlock eblock = ebr.readBlock();
			EthereumBlockHeader eblockHeader = eblock.getEthereumBlockHeader();
			List<EthereumTransaction> eTransactions = eblock.getEthereumTransactions();
			List<EthereumBlockHeader> eUncles = eblock.getUncleHeaders();
			assertEquals("Block contains 0 transactions", 0, eTransactions.size());
			assertEquals("Block contains 0 uncleHeaders",0, eUncles.size());
			byte[] expectedParentHash = new byte[] {(byte) 0xD4,(byte) 0xE5,0x67,0x40,(byte) 0xF8,0x76,(byte) 0xAE,(byte) 0xF8,(byte) 0xC0,0x10,(byte) 0xB8,0x6A,0x40,(byte) 0xD5,(byte) 0xF5,0x67,0x45,(byte) 0xA1,0x18,(byte) 0xD0,(byte) 0x90,0x6A,0x34,(byte) 0xE6,(byte) 0x9A,(byte) 0xEC,(byte) 0x8C,0x0D,(byte) 0xB1,(byte) 0xCB,(byte) 0x8F,(byte) 0xA3};
			
			assertArrayEquals("Block contains a correct 32 byte parent hash", expectedParentHash, eblockHeader.getParentHash());
			byte[] expectedUncleHash = new byte[] {(byte) 0x1D,(byte) 0xCC,0x4D,(byte) 0xE8,(byte) 0xDE, (byte) 0xC7,(byte) 0x5D,
					(byte) 0x7A,(byte) 0xAB,(byte) 0x85,(byte) 0xB5,(byte) 0x67,(byte) 0xB6,(byte) 0xCC,(byte) 0xD4,
					0x1A,(byte) 0xD3,(byte)0x12, 0x45,0x1B,(byte) 0x94,(byte) 0x8A,0x74,0x13,(byte) 0xF0,
					(byte) 0xA1,0x42,(byte) 0xFD,0x40,(byte) 0xD4,(byte) 0x93,0x47};
			assertArrayEquals("Block contains a correct 32 byte uncle hash", expectedUncleHash, eblockHeader.getUncleHash());
			byte[] expectedCoinbase = new byte[] {(byte)0x05,(byte)0xA5,(byte)0x6E,(byte)0x2D,(byte)0x52,(byte)0xC8,(byte)0x17,(byte)0x16,(byte)0x18,(byte)0x83,(byte)0xF5,(byte)0x0C,(byte)0x44,(byte)0x1C,(byte)0x32,(byte)0x28,(byte)0xCF,(byte)0xE5,(byte)0x4D,(byte)0x9F};
			assertArrayEquals("Block contains a correct  20 byte coinbase",expectedCoinbase,eblockHeader.getCoinBase());
			byte[] expectedStateRoot= new byte[] {(byte)0xD6,(byte)0x7E,(byte)0x4D,(byte)0x45,(byte)0x03,(byte)0x43,(byte)0x04,(byte)0x64,(byte)0x25,(byte)0xAE,(byte)0x42,(byte)0x71,(byte)0x47,(byte)0x43,(byte)0x53,(byte)0x85,(byte)0x7A,(byte)0xB8,(byte)0x60,(byte)0xDB,(byte)0xC0,(byte)0xA1,(byte)0xDD,(byte)0xE6,(byte)0x4B,(byte)0x41,(byte)0xB5,(byte)0xCD,(byte)0x3A,(byte)0x53,(byte)0x2B,(byte)0xF3};
			assertArrayEquals("Block contains a correct 32 byte stateroot",expectedStateRoot,eblockHeader.getStateRoot());
			byte[] expectedTxTrieRoot= new byte[] {0x56,(byte) 0xE8,0x1F,0x17,0x1B,(byte) 0xCC,0x55,(byte) 0xA6,(byte) 0xFF,(byte) 0x83,0x45,(byte) 0xE6,(byte) 0x92,(byte) 0xC0,(byte) 0xF8,0x6E,0x5B,0x48,(byte) 0xE0,0x1B,(byte) 0x99,0x6C,(byte) 0xAD,(byte) 0xC0,0x01,0x62,0x2F,(byte) 0xB5,(byte) 0xE3,0x63,(byte) 0xB4,0x21};
			assertArrayEquals("Block contains a correct 32 byte txTrieRoot",expectedTxTrieRoot,eblockHeader.getTxTrieRoot());	
			byte[] expectedReceiptTrieRoot=new byte[] {0x56,(byte) 0xE8,0x1F,0x17,0x1B,(byte) 0xCC,0x55,(byte) 0xA6,(byte) 0xFF,(byte) 0x83,0x45,(byte) 0xE6,(byte) 0x92,(byte) 0xC0,(byte) 0xF8,0x6E,0x5B,0x48,(byte) 0xE0,0x1B,(byte) 0x99,0x6C,(byte) 0xAD,(byte) 0xC0,0x01,0x62,0x2F,(byte) 0xB5,(byte) 0xE3,0x63,(byte) 0xB4,0x21};
			assertArrayEquals("Block contains a correct 32 byte ReceiptTrieRoot",expectedReceiptTrieRoot,eblockHeader.getReceiptTrieRoot());
			byte[] expectedLogsBloom = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Block contains a 256 byte log bloom consisting only of 0x00", expectedLogsBloom, eblockHeader.getLogsBloom());
			byte[] expectedDifficulty = new byte[] {0x03,(byte) 0xFF,(byte) 0x80,0x00,0x00};
			assertArrayEquals("Block contains a correct 5 byte difficulty", expectedDifficulty, eblockHeader.getDifficulty());
			DateFormat format = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss z");
			String expectedDTStr = "30-07-2015 15:26:28 UTC";
			long expectedTimestamp = format.parse(expectedDTStr).getTime() / 1000;
			//1438269988
			assertEquals("Block contains a timestamp of "+expectedDTStr,expectedTimestamp, eblockHeader.getTimestamp());
			long expectedNumber = 1L;
			assertEquals("Block contains a number 1", expectedNumber, eblockHeader.getNumber());
			byte[] expectedGasLimit = new byte[] {0x13,(byte) 0x88};
			assertArrayEquals("Block contains a correct 2 byte gas limit", expectedGasLimit, eblockHeader.getGasLimit());
			long expectedGasUsed = 0L;
			assertEquals("Block contains a gas used of  0", expectedGasUsed, eblockHeader.getGasUsed());
			byte[] expectedMixHash= new byte[] {(byte)0x96,(byte)0x9B,(byte)0x90,(byte)0x0D,(byte)0xE2,(byte)0x7B,(byte)0x6A,(byte)0xC6,(byte)0xA6,(byte)0x77,(byte)0x42,(byte)0x36,(byte)0x5D,(byte)0xD6,(byte)0x5F,(byte)0x55,(byte)0xA0,(byte)0x52,(byte)0x6C,(byte)0x41,(byte)0xFD,(byte)0x18,(byte)0xE1,(byte)0xB1,(byte)0x6F,(byte)0x1A,(byte)0x12,(byte)0x15,(byte)0xC2,(byte)0xE6,(byte)0x6F,(byte)0x59};
			assertArrayEquals("Block contains a correct 32 byte mix hash", expectedMixHash, eblockHeader.getMixHash());
			byte[] expectedExtraData= new byte[] {(byte)0x47,(byte)0x65,(byte)0x74,(byte)0x68,(byte)0x2F,(byte)0x76,(byte)0x31,(byte)0x2E,(byte)0x30,(byte)0x2E,(byte)0x30,(byte)0x2F,(byte)0x6C,(byte)0x69,(byte)0x6E,(byte)0x75,(byte)0x78,(byte)0x2F,(byte)0x67,(byte)0x6F,(byte)0x31,(byte)0x2E,(byte)0x34,(byte)0x2E,(byte)0x32};
			// corresponds to Geth/v1.0.0/linux/go1.4.2
			assertArrayEquals("Block contains correct 32 byte extra data", expectedExtraData, eblockHeader.getExtraData());
			byte[] expectedNonce = new byte[] {(byte)0x53,(byte)0x9B,(byte)0xD4,(byte)0x97,(byte)0x9F,(byte)0xEF,(byte)0x1E,(byte)0xC4};
			assertArrayEquals("Block contains a correct 8 byte nonce", expectedNonce, eblockHeader.getNonce());
		} finally {
			if (ebr!=null) {
				ebr.close();
			}
		}
	  }
	 
	 @Test
	  public void parseBlockOneAsEthereumBlockDirect() throws IOException, EthereumBlockReadException, ParseException {
			ClassLoader classLoader = getClass().getClassLoader();
			String fileName="eth1.bin";
			String fileNameBlock=classLoader.getResource("testdata/"+fileName).getFile();	
			File file = new File(fileNameBlock);
			boolean direct=true;
			FileInputStream fin = new FileInputStream(file);
			EthereumBlockReader ebr = null;
			try {
				ebr = new EthereumBlockReader(fin,this.DEFAULT_MAXSIZE_ETHEREUMBLOCK, this.DEFAULT_BUFFERSIZE,direct);
				EthereumBlock eblock = ebr.readBlock();
				EthereumBlockHeader eblockHeader = eblock.getEthereumBlockHeader();
				List<EthereumTransaction> eTransactions = eblock.getEthereumTransactions();
				List<EthereumBlockHeader> eUncles = eblock.getUncleHeaders();
				assertEquals("Block contains 0 transactions", 0, eTransactions.size());
				assertEquals("Block contains 0 uncleHeaders",0, eUncles.size());
				byte[] expectedParentHash = new byte[] {(byte) 0xD4,(byte) 0xE5,0x67,0x40,(byte) 0xF8,0x76,(byte) 0xAE,(byte) 0xF8,(byte) 0xC0,0x10,(byte) 0xB8,0x6A,0x40,(byte) 0xD5,(byte) 0xF5,0x67,0x45,(byte) 0xA1,0x18,(byte) 0xD0,(byte) 0x90,0x6A,0x34,(byte) 0xE6,(byte) 0x9A,(byte) 0xEC,(byte) 0x8C,0x0D,(byte) 0xB1,(byte) 0xCB,(byte) 0x8F,(byte) 0xA3};
				
				assertArrayEquals("Block contains a correct 32 byte parent hash", expectedParentHash, eblockHeader.getParentHash());
				byte[] expectedUncleHash = new byte[] {(byte) 0x1D,(byte) 0xCC,0x4D,(byte) 0xE8,(byte) 0xDE, (byte) 0xC7,(byte) 0x5D,
						(byte) 0x7A,(byte) 0xAB,(byte) 0x85,(byte) 0xB5,(byte) 0x67,(byte) 0xB6,(byte) 0xCC,(byte) 0xD4,
						0x1A,(byte) 0xD3,(byte)0x12, 0x45,0x1B,(byte) 0x94,(byte) 0x8A,0x74,0x13,(byte) 0xF0,
						(byte) 0xA1,0x42,(byte) 0xFD,0x40,(byte) 0xD4,(byte) 0x93,0x47};
				assertArrayEquals("Block contains a correct 32 byte uncle hash", expectedUncleHash, eblockHeader.getUncleHash());
				byte[] expectedCoinbase = new byte[] {(byte)0x05,(byte)0xA5,(byte)0x6E,(byte)0x2D,(byte)0x52,(byte)0xC8,(byte)0x17,(byte)0x16,(byte)0x18,(byte)0x83,(byte)0xF5,(byte)0x0C,(byte)0x44,(byte)0x1C,(byte)0x32,(byte)0x28,(byte)0xCF,(byte)0xE5,(byte)0x4D,(byte)0x9F};
				assertArrayEquals("Block contains a correct  20 byte coinbase",expectedCoinbase,eblockHeader.getCoinBase());
				byte[] expectedStateRoot= new byte[] {(byte)0xD6,(byte)0x7E,(byte)0x4D,(byte)0x45,(byte)0x03,(byte)0x43,(byte)0x04,(byte)0x64,(byte)0x25,(byte)0xAE,(byte)0x42,(byte)0x71,(byte)0x47,(byte)0x43,(byte)0x53,(byte)0x85,(byte)0x7A,(byte)0xB8,(byte)0x60,(byte)0xDB,(byte)0xC0,(byte)0xA1,(byte)0xDD,(byte)0xE6,(byte)0x4B,(byte)0x41,(byte)0xB5,(byte)0xCD,(byte)0x3A,(byte)0x53,(byte)0x2B,(byte)0xF3};
				assertArrayEquals("Block contains a correct 32 byte stateroot",expectedStateRoot,eblockHeader.getStateRoot());
				byte[] expectedTxTrieRoot= new byte[] {0x56,(byte) 0xE8,0x1F,0x17,0x1B,(byte) 0xCC,0x55,(byte) 0xA6,(byte) 0xFF,(byte) 0x83,0x45,(byte) 0xE6,(byte) 0x92,(byte) 0xC0,(byte) 0xF8,0x6E,0x5B,0x48,(byte) 0xE0,0x1B,(byte) 0x99,0x6C,(byte) 0xAD,(byte) 0xC0,0x01,0x62,0x2F,(byte) 0xB5,(byte) 0xE3,0x63,(byte) 0xB4,0x21};
				assertArrayEquals("Block contains a correct 32 byte txTrieRoot",expectedTxTrieRoot,eblockHeader.getTxTrieRoot());	
				byte[] expectedReceiptTrieRoot=new byte[] {0x56,(byte) 0xE8,0x1F,0x17,0x1B,(byte) 0xCC,0x55,(byte) 0xA6,(byte) 0xFF,(byte) 0x83,0x45,(byte) 0xE6,(byte) 0x92,(byte) 0xC0,(byte) 0xF8,0x6E,0x5B,0x48,(byte) 0xE0,0x1B,(byte) 0x99,0x6C,(byte) 0xAD,(byte) 0xC0,0x01,0x62,0x2F,(byte) 0xB5,(byte) 0xE3,0x63,(byte) 0xB4,0x21};
				assertArrayEquals("Block contains a correct 32 byte ReceiptTrieRoot",expectedReceiptTrieRoot,eblockHeader.getReceiptTrieRoot());
				byte[] expectedLogsBloom = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
				assertArrayEquals("Block contains a 256 byte log bloom consisting only of 0x00", expectedLogsBloom, eblockHeader.getLogsBloom());
				byte[] expectedDifficulty = new byte[] {0x03,(byte) 0xFF,(byte) 0x80,0x00,0x00};
				assertArrayEquals("Block contains a correct 5 byte difficulty", expectedDifficulty, eblockHeader.getDifficulty());
				DateFormat format = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss z");
				String expectedDTStr = "30-07-2015 15:26:28 UTC";
				long expectedTimestamp = format.parse(expectedDTStr).getTime() / 1000;
				//1438269988
				assertEquals("Block contains a timestamp of "+expectedDTStr,expectedTimestamp, eblockHeader.getTimestamp());
				long expectedNumber = 1L;
				assertEquals("Block contains a number 1", expectedNumber, eblockHeader.getNumber());
				byte[] expectedGasLimit = new byte[] {0x13,(byte) 0x88};
				assertArrayEquals("Block contains a correct 2 byte gas limit", expectedGasLimit, eblockHeader.getGasLimit());
				long expectedGasUsed = 0L;
				assertEquals("Block contains a gas used of  0", expectedGasUsed, eblockHeader.getGasUsed());
				byte[] expectedMixHash= new byte[] {(byte)0x96,(byte)0x9B,(byte)0x90,(byte)0x0D,(byte)0xE2,(byte)0x7B,(byte)0x6A,(byte)0xC6,(byte)0xA6,(byte)0x77,(byte)0x42,(byte)0x36,(byte)0x5D,(byte)0xD6,(byte)0x5F,(byte)0x55,(byte)0xA0,(byte)0x52,(byte)0x6C,(byte)0x41,(byte)0xFD,(byte)0x18,(byte)0xE1,(byte)0xB1,(byte)0x6F,(byte)0x1A,(byte)0x12,(byte)0x15,(byte)0xC2,(byte)0xE6,(byte)0x6F,(byte)0x59};
				assertArrayEquals("Block contains a correct 32 byte mix hash", expectedMixHash, eblockHeader.getMixHash());
				byte[] expectedExtraData= new byte[] {(byte)0x47,(byte)0x65,(byte)0x74,(byte)0x68,(byte)0x2F,(byte)0x76,(byte)0x31,(byte)0x2E,(byte)0x30,(byte)0x2E,(byte)0x30,(byte)0x2F,(byte)0x6C,(byte)0x69,(byte)0x6E,(byte)0x75,(byte)0x78,(byte)0x2F,(byte)0x67,(byte)0x6F,(byte)0x31,(byte)0x2E,(byte)0x34,(byte)0x2E,(byte)0x32};
				// corresponds to Geth/v1.0.0/linux/go1.4.2
				assertArrayEquals("Block contains correct 32 byte extra data", expectedExtraData, eblockHeader.getExtraData());
				byte[] expectedNonce = new byte[] {(byte)0x53,(byte)0x9B,(byte)0xD4,(byte)0x97,(byte)0x9F,(byte)0xEF,(byte)0x1E,(byte)0xC4};
				assertArrayEquals("Block contains a correct 8 byte nonce", expectedNonce, eblockHeader.getNonce());
			} finally {
				if (ebr!=null) {
					ebr.close();
				}
			}
	  }

	 
	 @Test
	  public void parseBlock1346406AsEthereumBlockHeap() throws IOException, EthereumBlockReadException, ParseException {
		ClassLoader classLoader = getClass().getClassLoader();
		String fileName="eth1346406.bin";
		String fileNameBlock=classLoader.getResource("testdata/"+fileName).getFile();	
		File file = new File(fileNameBlock);
		boolean direct=false;
		FileInputStream fin = new FileInputStream(file);
		EthereumBlockReader ebr = null;
		try {
			ebr = new EthereumBlockReader(fin,this.DEFAULT_MAXSIZE_ETHEREUMBLOCK, this.DEFAULT_BUFFERSIZE,direct);
			EthereumBlock eblock = ebr.readBlock();
			EthereumBlockHeader eblockHeader = eblock.getEthereumBlockHeader();
			List<EthereumTransaction> eTransactions = eblock.getEthereumTransactions();
			List<EthereumBlockHeader> eUncles = eblock.getUncleHeaders();
			assertEquals("Block contains 6 transactions", 6, eTransactions.size());
			assertEquals("Block contains 0 uncleHeaders",0, eUncles.size());
			byte[] expectedParentHash = new byte[] {(byte)0xBA,(byte)0x6D,(byte)0xD2,(byte)0x60,(byte)0x12,(byte)0xB3,(byte)0x71,(byte)0x90,(byte)0x48,(byte)0xF3,(byte)0x16,(byte)0xC6,(byte)0xED,(byte)0xB3,(byte)0x34,(byte)0x9B,(byte)0xDF,(byte)0xBD,(byte)0x61,(byte)0x31,(byte)0x9F,(byte)0xA9,(byte)0x7C,(byte)0x61,(byte)0x6A,(byte)0x61,(byte)0x31,(byte)0x18,(byte)0xA1,(byte)0xAF,(byte)0x30,(byte)0x67};
			
			assertArrayEquals("Block contains a correct 32 byte parent hash", expectedParentHash, eblockHeader.getParentHash());
			byte[] expectedUncleHash = new byte[] {(byte) 0x1D,(byte) 0xCC,0x4D,(byte) 0xE8,(byte) 0xDE, (byte) 0xC7,(byte) 0x5D,
					(byte) 0x7A,(byte) 0xAB,(byte) 0x85,(byte) 0xB5,(byte) 0x67,(byte) 0xB6,(byte) 0xCC,(byte) 0xD4,
					0x1A,(byte) 0xD3,(byte)0x12, 0x45,0x1B,(byte) 0x94,(byte) 0x8A,0x74,0x13,(byte) 0xF0,
					(byte) 0xA1,0x42,(byte) 0xFD,0x40,(byte) 0xD4,(byte) 0x93,0x47};
			assertArrayEquals("Block contains a correct 32 byte uncle hash", expectedUncleHash, eblockHeader.getUncleHash());
			byte[] expectedCoinbase = new byte[] {(byte)0x1A,(byte)0x06,(byte)0x0B,(byte)0x06,(byte)0x04,(byte)0x88,(byte)0x3A,(byte)0x99,(byte)0x80,(byte)0x9E,(byte)0xB3,(byte)0xF7,(byte)0x98,(byte)0xDF,(byte)0x71,(byte)0xBE,(byte)0xF6,(byte)0xC3,(byte)0x58,(byte)0xF1};
			assertArrayEquals("Block contains a correct  20 byte coinbase",expectedCoinbase,eblockHeader.getCoinBase());
			byte[] expectedStateRoot= new byte[] {(byte)0x21,(byte)0xBA,(byte)0x88,(byte)0x6F,(byte)0xD2,(byte)0x6F,(byte)0x17,(byte)0xB4,(byte)0x01,(byte)0xF5,(byte)0x39,(byte)0x20,(byte)0x15,(byte)0x33,(byte)0x10,(byte)0xB6,(byte)0x93,(byte)0x9B,(byte)0xAD,(byte)0x8A,(byte)0x5F,(byte)0xC3,(byte)0xBF,(byte)0x8C,(byte)0x50,(byte)0x5C,(byte)0x55,(byte)0x6D,(byte)0xDB,(byte)0xAF,(byte)0xBC,(byte)0x5C};
			assertArrayEquals("Block contains a correct 32 byte stateroot",expectedStateRoot,eblockHeader.getStateRoot());
			byte[] expectedTxTrieRoot= new byte[] {(byte)0xB3,(byte)0xCB,(byte)0xC7,(byte)0xF0,(byte)0xD7,(byte)0x87,(byte)0xE5,(byte)0x7D,(byte)0x93,(byte)0x70,(byte)0xB8,(byte)0x02,(byte)0xAB,(byte)0x94,(byte)0x5E,(byte)0x21,(byte)0x99,(byte)0x1C,(byte)0x3E,(byte)0x12,(byte)0x7D,(byte)0x70,(byte)0x12,(byte)0x0C,(byte)0x37,(byte)0xE9,(byte)0xFD,(byte)0xAE,(byte)0x3E,(byte)0xF3,(byte)0xEB,(byte)0xFC};
			assertArrayEquals("Block contains a correct 32 byte txTrieRoot",expectedTxTrieRoot,eblockHeader.getTxTrieRoot());	
			byte[] expectedReceiptTrieRoot=new byte[] {(byte)0x9B,(byte)0xCE,(byte)0x71,(byte)0x32,(byte)0xF5,(byte)0x2D,(byte)0x4D,(byte)0x45,(byte)0xA8,(byte)0xA2,(byte)0x47,(byte)0x48,(byte)0x47,(byte)0x86,(byte)0xC7,(byte)0x0B,(byte)0xB2,(byte)0xE6,(byte)0x39,(byte)0x59,(byte)0xC8,(byte)0x56,(byte)0x1B,(byte)0x3A,(byte)0xBF,(byte)0xD4,(byte)0xE7,(byte)0x22,(byte)0xE6,(byte)0x00,(byte)0x6A,(byte)0x27};
			assertArrayEquals("Block contains a correct 32 byte ReceiptTrieRoot",expectedReceiptTrieRoot,eblockHeader.getReceiptTrieRoot());
			byte[] expectedLogsBloom = new byte[] {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			assertArrayEquals("Block contains a 256 byte log bloom consisting only of 0x00", expectedLogsBloom, eblockHeader.getLogsBloom());
			byte[] expectedDifficulty = new byte[] {0x19,(byte) 0xFF,(byte) 0x9E,(byte) 0xC4,0x35,(byte) 0xE0};
	
			assertArrayEquals("Block contains a correct 5 byte difficulty", expectedDifficulty, eblockHeader.getDifficulty());
			DateFormat format = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss z");
			String expectedDTStr = "16-04-2016 09:34:29 UTC";
			long expectedTimestamp = format.parse(expectedDTStr).getTime() / 1000;
			//1438269988
			assertEquals("Block cotains a timestamp of "+expectedDTStr,expectedTimestamp, eblockHeader.getTimestamp());
			long expectedNumber = 1346406L;
			assertEquals("Block contains a number 1346406", expectedNumber, eblockHeader.getNumber());
			byte[] expectedGasLimit = new byte[] {0x47,(byte) 0xE7,(byte) 0xC4}; 
			assertArrayEquals("Block contains a correct 3 byte gas limit", expectedGasLimit, eblockHeader.getGasLimit());
			long expectedGasUsed = 126000L;
			assertEquals("Block contains a gas used of  126000", expectedGasUsed, eblockHeader.getGasUsed());
			byte[] expectedMixHash= new byte[] {(byte)0x4F,(byte)0x57,(byte)0x71,(byte)0xB7,(byte)0x9A,(byte)0x8E,(byte)0x6E,(byte)0x21,(byte)0x99,(byte)0x35,(byte)0x53,(byte)0x9C,(byte)0x47,(byte)0x3E,(byte)0x23,(byte)0xBA,(byte)0xFD,(byte)0x2C,(byte)0xA3,(byte)0x5C,(byte)0xC1,(byte)0x86,(byte)0x20,(byte)0x66,(byte)0x31,(byte)0xC3,(byte)0xB0,(byte)0x9E,(byte)0xD5,(byte)0x76,(byte)0x19,(byte)0x4A};
			assertArrayEquals("Block contains a correct 32 byte mix hash", expectedMixHash, eblockHeader.getMixHash());
			byte[] expectedExtraData= new byte[] {(byte)0xD7,(byte)0x83,(byte)0x01,(byte)0x03,(byte)0x05,(byte)0x84,(byte)0x47,(byte)0x65,(byte)0x74,(byte)0x68,(byte)0x87,(byte)0x67,(byte)0x6F,(byte)0x31,(byte)0x2E,(byte)0x35,(byte)0x2E,(byte)0x31,(byte)0x85,(byte)0x6C,(byte)0x69,(byte)0x6E,(byte)0x75,(byte)0x78};
			// corresponds to 010305/Geth/go1.5.1/linux
			assertArrayEquals("Block contains correct 24 byte extra data", expectedExtraData, eblockHeader.getExtraData());
			byte[] expectedNonce = new byte[] {(byte)0xFF,(byte)0x7C,(byte)0x7A,(byte)0xEE,(byte)0x0E,(byte)0x88,(byte)0xC5,(byte)0x2D};
			assertArrayEquals("Block contains a correct 8 byte nonce", expectedNonce, eblockHeader.getNonce());
			// check transactions
		} finally {
			if (ebr!=null) {
				ebr.close();
			}
		}
	  }
}
